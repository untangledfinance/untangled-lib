//
// THIS FILE WAS GENERATED BY GITHUB COPILOT!!!
// PLEASE REPORT IF YOU FIND ANY ISSUE HERE!!!
//

import {
  configure,
  CorsOptions,
  Filter,
  FilterOptions,
  Handler,
  HttpMethod,
  Req,
  Res,
  RouteOptions,
  Router,
  ServeOptions,
  Server,
  StatusCode,
} from '../core';
import { HttpError, NotFoundError } from '../error';
import { isClass, profiles } from '../../types';
import { Step } from '../../validation';
import fastify, {
  FastifyInstance,
  FastifyPluginCallback,
  FastifyReply,
  FastifyRequest,
  RouteOptions as FastifyRouteOptions,
} from 'fastify';
import fastifyHelmet from '@fastify/helmet';
import fastifyCors from '@fastify/cors';
import { createLogger } from '../../logging';

const logger = createLogger('fastify');

class Mapper {
  static toReq(req: FastifyRequest) {
    return {
      method: req.method,
      path: req.url,
      headers: req.headers as Record<string, string | string[]>,
      query: req.query as Record<string, string | string[]>,
      params: req.params as Record<string, string | string[]>,
      body: req.body,
    } as Req;
  }

  static toRes(res: FastifyReply) {
    return {
      status: res.statusCode ?? StatusCode.OK,
      headers: res.getHeaders(),
    } as Res;
  }

  static corsOptions(options: Partial<CorsOptions> = {}) {
    const { allowedOrigins, allowedHeaders, allowedMethods, maxAge } = options;

    return {
      origin: allowedOrigins
        ? allowedOrigins === '*' || allowedOrigins.includes('*')
          ? true
          : [allowedOrigins].flat()
        : false,
      methods: allowedMethods
        ? allowedMethods === '*' || allowedMethods.includes('*')
          ? ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD']
          : [allowedMethods].flat()
        : undefined,
      allowedHeaders: allowedHeaders
        ? allowedHeaders === '*' || allowedHeaders.includes('*')
          ? '*'
          : [allowedHeaders].flat()
        : undefined,
      maxAge: maxAge !== undefined ? parseInt(maxAge.toString()) : 5,
    };
  }
}

export abstract class Group implements Router {
  protected fastifyApp?: FastifyInstance;
  protected corsOptions?: Partial<CorsOptions>;
  protected errorHandler?: (err: Error, req: Req) => Promise<Res>;
  private eventHandlers: Map<string, Function[]> = new Map();
  private filters: Map<Class<Router> | '*', Filter[]> = new Map();
  private routes: Map<string, any> = new Map();

  protected configure(...filters: Filter[]) {
    configure(this, ...(this.filters.get('*') ?? []), ...filters);
  }

  @Step(1)
  with({ guard: filter, before }: FilterOptions) {
    const routers = before instanceof Array ? before : [before];
    routers.forEach((rc) => {
      const fs = this.filters.get(rc) ?? [];
      fs.push(filter);
      this.filters.set(rc, fs);
    });
    return this;
  }

  @Step(1)
  guard(filter: Filter) {
    this.filters.set('*', [...(this.filters.get('*') ?? []), filter]);
    return this;
  }

  /**
   * Tries sending the {@link Res}.
   */
  protected async send(res: FastifyReply, { data, status, headers }: Res) {
    if (!res.sent) {
      if (headers) {
        for (const key of Object.keys(headers)) {
          res.header(key, headers[key]);
        }
      }

      if (status) {
        res.status(status);
      }

      if (data !== undefined) {
        await res.send(data);
      } else {
        await res.send();
      }
    }
  }

  apply({ routes, fetcher, error }: Partial<RouteOptions>) {
    this.fastifyApp = fastify({
      logger: false,
    });

    if (routes?.length && fetcher) {
      for (const route of routes) {
        const fetch = fetcher.bind(this)(route);
        const method = route.method.toLowerCase();
        const path = route.path;

        if (method === '*') {
          this.fastifyApp.all(path, async (request, reply) => {
            await this.send(
              reply,
              await fetch(Mapper.toReq(request), Mapper.toRes(reply))
            );
          });
        } else {
          this.fastifyApp.route({
            method: method === '*' ? 'all' : (method as any),
            url: path,
            handler: async (request, reply) => {
              await this.send(
                reply,
                await fetch(Mapper.toReq(request), Mapper.toRes(reply))
              );
            },
          });
        }
      }
      this.errorHandler = error;
    }
    return this;
  }

  @Step(0)
  cors(options: Partial<CorsOptions> | '*') {
    if (options === '*') {
      this.corsOptions = {
        allowedOrigins: ['*'],
        allowedMethods: ['*'],
        allowedHeaders: ['*'],
      };
    } else {
      this.corsOptions = options;
    }
    return this;
  }

  @Step(2)
  _route(method: HttpMethod, path: string, handler: Handler) {
    !this.fastifyApp && this.configure();

    const routeMethod = method.toLowerCase() as any;
    this.fastifyApp!.route({
      method:
        routeMethod === 'all'
          ? ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD']
          : routeMethod,
      url: path,
      handler: async (request, reply) => {
        try {
          await this.send(
            reply,
            await handler(Mapper.toReq(request), Mapper.toRes(reply))
          );
        } catch (err) {
          if (!(err instanceof HttpError)) {
            logger.error(`${err.message}\n`, err);
          }
          await this.send(
            reply,
            await this.errorHandler!(err as Error, Mapper.toReq(request))
          );
        }
      },
    });

    return this;
  }

  route(method: HttpMethod, path: string, handler: Handler) {
    return this._route(method, path, handler);
  }

  /**
   * @see {@link route}.
   */
  get(path: string, handler: Handler) {
    return this._route('GET', path, handler);
  }

  /**
   * @see {@link route}.
   */
  post(path: string, handler: Handler) {
    return this._route('POST', path, handler);
  }

  /**
   * @see {@link route}.
   */
  put(path: string, handler: Handler) {
    return this._route('PUT', path, handler);
  }

  /**
   * @see {@link route}.
   */
  patch(path: string, handler: Handler) {
    return this._route('PATCH', path, handler);
  }

  /**
   * @see {@link route}.
   */
  delete(path: string, handler: Handler) {
    return this._route('DELETE', path, handler);
  }

  @Step(2)
  _use(prefix: string, ...args: [...Filter[], Class<Group>, ...any]) {
    !this.fastifyApp && this.configure();

    const filters: Filter[] = [];
    for (let i = 0; i < args.length; i++) {
      if (isClass(args[i])) {
        const group = args[i] as Class<Group>;
        const groupArgs = args.slice(i + 1);
        const g = new (class extends group {})(...groupArgs) as Group;
        !g.fastifyApp &&
          g.configure(
            ...(this.filters.get('*') ?? []),
            ...filters,
            ...(this.filters.get(group) ?? [])
          );

        // Create a plugin that registers the nested app
        const registerSubApp: FastifyPluginCallback = (subApp, opts, done) => {
          if (g.fastifyApp) {
            // For Fastify, we need to manually handle routes transfer
            // Create a plugin to handle all routes from child app
            try {
              // Clone routes by registering similar handlers for each route
              const routes = g.routes.values();
              for (const route of routes) {
                subApp.route(route);
              }
              done();
            } catch (err) {
              done(err as Error);
            }
          } else {
            done(new Error('Nested Fastify app is not initialized'));
          }
        };

        // Register the sub-app
        this.fastifyApp!.register(registerSubApp, { prefix });

        // Handle CORS for the group if specified
        if (g.corsOptions) {
          const corsOptions = Mapper.corsOptions(g.corsOptions);
          this.fastifyApp!.register(fastifyCors, {
            ...corsOptions,
            prefix,
          });
        }

        break;
      }
      filters.push(args[i] as Filter);
    }
    return this;
  }

  use(prefix: string, group: Class<Group>, ...args: any[]) {
    return this._use(prefix, group, ...args);
  }

  on(event: string, handler: Function) {
    const handlers = this.eventHandlers.get(event) ?? [];
    handlers.push(handler);
    this.eventHandlers.set(event, handlers);
    return this;
  }

  emit(event: string, ...data: any[]) {
    const handlers = this.eventHandlers.get(event) ?? [];
    handlers.forEach((handler) => handler(...data));
    return this;
  }
}

/**
 * Events emitted by the {@link Server}.
 */
type ServerEvent =
  | 'crashed'
  | 'start'
  | 'started'
  | 'stop'
  | 'stopped'
  | 'request'
  | 'response';

/**
 * A Fastify-embedded HTTP server.
 */
export abstract class Application extends Group implements Server {
  private server?: FastifyInstance;
  private isListening = false;
  private isClosing = false;

  async start({ host, port }: Partial<ServeOptions>) {
    !this.fastifyApp && configure(this);

    if (this.isListening) {
      throw new Error('Already served!');
    }

    this.emit('start');
    this.server = this.fastifyApp!;

    // Setup core plugins
    await this.server.register(fastifyHelmet);

    // Setup CORS if configured
    if (this.corsOptions) {
      await this.server.register(
        fastifyCors,
        Mapper.corsOptions(this.corsOptions)
      );
    }

    // Request event middleware
    this.server.addHook('onRequest', (request, reply, done) => {
      this.emit('request', Mapper.toReq(request));
      done();
    });

    // Response event middleware
    this.server.addHook('onResponse', (request, reply, done) => {
      this.emit('response', Mapper.toReq(request), Mapper.toRes(reply));
      done();
    });

    // Not found handler
    this.server.setNotFoundHandler(async (request, reply) => {
      if (this.errorHandler) {
        const res = await this.errorHandler(
          new NotFoundError(),
          Mapper.toReq(request)
        );
        await this.send(reply, res);
      } else {
        reply.status(404).send({ error: 'Not Found' });
      }
    });

    // Error handler
    this.server.setErrorHandler(async (error, request, reply) => {
      if (!(error instanceof HttpError)) {
        logger.error(`${error.message}\n`, error);
      }

      if (this.errorHandler) {
        const res = await this.errorHandler(error, Mapper.toReq(request));
        await this.send(reply, res);
      } else {
        reply.status(500).send({ error: 'Internal Server Error' });
      }
    });

    try {
      // Start the server
      await this.server.listen({ port: port || 3000, host: host || '0.0.0.0' });
      this.isListening = true;

      this.emit('started', {
        app: {
          type: 'fastify',
          env: process.env.ENV,
          profiles: [...profiles()],
          host,
          port,
        },
      });

      return this;
    } catch (err) {
      this.emit('crashed');
      throw err;
    }
  }

  async stop() {
    this.emit('stop');
    if (this.server && !this.isClosing) {
      this.isClosing = true;
      await this.server.close();
      this.isListening = false;
      this.isClosing = false;
      this.emit('stopped');
    }
  }

  override on(event: ServerEvent, handler: Function) {
    return super.on(event, handler);
  }

  override emit(event: ServerEvent, ...data: any[]) {
    return super.emit(event, ...data);
  }
}
